classdef feedbackAttack
    %feedbackAttack Summary of this class goes here

    properties
       Q_G; G; Q_K; K; P_W; H; V; Q;
    end

    methods
        function obj = feedbackAttack(Q_G, G, Q_K, K, P_W)
            %feedbackAttack Construct an instance of this class
            % store attributes and construct the vulnerability matrix V
            n = size(Q_G, 1) + size(Q_K, 1);
            if P_W == 0
                P_W = eye(n);
            end

            Q = [Q_G (eye(size(Q_G, 1)) - Q_G) * G;
                (eye(size(Q_K, 1)) - Q_K) * K Q_K];
            I = eye(n);

            Gamma = inv([eye(size(G)) -G; -K eye(size(K))]);

            IminusQ_inv = Gamma * diag([inv(eye(size(Q_G, 1)) - Q_G) inv(eye(size(Q_K, 1)) - Q_K)]);
            H = IminusQ_inv * P_W;

            V = zeros(n, n);  % unaware of broadcasting possibility with hinfnorm
            for i = 1:n 
                for j = 1:n
                    [num, den] = numden(H(i,j));  % num/den of tf entry
                    % coeffs(s^3 + 3s^2 + 10, "All") -> [1, 3, 0, 10]
                    num_coeffs = coeffs(num, "All");
                    den_coeffs = coeffs(den, "All");
                    % convert coeffs to matlab array
                    tf_ij = tf(double(num_coeffs), double(den_coeffs));
                    V(i, j) = hinfnorm(tf_ij);  % entry wise inf norm
                end
            end

            obj.Q_G = Q_G; obj.Q_K = Q_K; obj.G = G; obj.K = K;
            obj.V = V; obj.Q = Q; obj.H = H; obj.P_W = P_W;

        end

        function vulnerability = vul(obj)
            % Compute vulnerability
            %   Max of V
            vulnerability = max(obj.V(:));
        end
    end
end