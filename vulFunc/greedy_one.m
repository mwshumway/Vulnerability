function [policy] = greedy_one(A, B)
%GREEDY_ONE Implement the greedy algorithm of the first kind.
%   Immerse the state associated with the column containing the largest 
%   vulnerability (i.e. the column of $V_Y$ containing the largest entry).
% NOTE - Right now, not super optimized code. I just want to make sure that
% this initially works.
% TODO - read over this with fresh eyes - I'm not convinced this is the
% best yet.
    disp(A)
    n = size(A, 1);
    dsf = DSF(A, B);
    [Q, ~] = dsf.dsf(n);
    H = dsf.vulnerability_matrix(Q);
    [~, idx, V] = dsf.eval_vulnerability(H);
    abstract_me = idx(2);

    % need a way to properly keep track of nodes labels even when they're
    % switched

    nodes = linspace(1, n, n); % nodes(i) = current index of this node

    policy = [abstract_me];
    for i = n:-1:2

        new_A = A;  % make a copy
        % swap the 'abstract_me' col and row with the i-th.
        new_A([abstract_me, i], :) = new_A([i, abstract_me], :); 
        new_A(:, [abstract_me, i], :) = new_A(:, [i, abstract_me]);
        temp = nodes(abstract_me);
        nodes(abstract_me) = nodes(i);
        nodes(i) = temp;
        new_dsf = DSF(new_A, B);
        [new_Q, ~] = new_dsf.dsf(i-1);
        new_H = new_dsf.vulnerability_matrix(new_Q);
        [~, new_idx, V] = new_dsf.eval_vulnerability(new_H);
        abstract_me = new_idx(2);  % the col to abstract.
        policy = [policy; nodes(abstract_me)];
    end

end