function [not_sub] = determine_submodularity(A)
%DETERMINE_SUBMODULARITY return 0 if submodular and 1 if not.
%   V(A, B) is submodular if abstracting state x early on (with more states
%   exposed) has a larger vulnerability than if we abstract state x later
%   (with less exposed states)

% NOTE - the genius behind these bit operations is Gabriel Perry. Reach out
% to him if you need extra help understanding what's going on.
    [n, ~] = size(A);
    not_sub = 0;

    % initialize a map (index : DSF2 object)
    keys = num2cell(0:(2^n-1));
    vals = cell(1, 2^n);
    tests = containers.Map(keys, vals);

    tests(2^n-1) = DSF2(A); % tests(2^n-1) will be a dsf2 object

    for i = (2^n-2):-1:0
        tests(i) = tests(2^n-1).immerse(i);  % number of immersions
    end

    for Z = 0: 2^n - 1
        for diff = 0: 2^n -1
            Y = bitor(Z, diff);
            for i = 0: n-1
                x = 2^i;
                if bitand(x, Y)
                    % below is the definition of submodularity
                    add_to_subset = tests(bitor(Z, x)).vulnerability - tests(Z).vulnerability;
                    add_to_superset = tests(bitor(Y, x)).vulnerability - tests(Y).vulnerability;
                    if add_to_subset < add_to_superset
                        not_sub = 1;
                        return;
                    end
                end
            end
        end
    end
end