classdef DSF
    % DSF Contains many useful functions for Computing DSF 
    % and calculating vulnerabilities
    % Class accepts as inputs the system (A,B) 

    properties  % 'attributes'
        A
        B
    end

    methods (Static)
        function obj = DSF(inputA, inputB)
        % Constructor for the DSF class
        % Parameters:
        %   inputA
        %   inputB 
            
           % First, make sure that the system is stable.
            eigenvalues_A = eig(inputA);

            % Check if the real part of all eigenvalues are negative
            if any(real(eigenvalues_A) >= -1e-8)
                error('The real part of all eigenvalues of A must be negative.');
            end
  
            obj.A = inputA;
            obj.B = inputB;
        end

        function I = identity_like(M)
           % Compute identity of size M
           [n, ~] = size(M);
           I = eye(n);
        end

        function INV = sI_MINV(M)
            % Compute the inverse of (sI-M)
            syms s;
            I = DSF.identity_like(M);
            INV = inv(s*I - M);
        end
    end

    methods

        function [Q, P] = dsf(obj, num_exposed)
            % Compute the dsf of the system. 
            % Parameters:
            %   num_exposed : row_rank(C). 

            % Partition matrices

            A1 = obj.A(1:num_exposed, 1:num_exposed);
            A2 = obj.A(1:num_exposed, num_exposed+1:end);
            A3 = obj.A(num_exposed+1:end, 1:num_exposed);
            A4 = obj.A(num_exposed+1:end, num_exposed+1:end);

            B1 = obj.B(1:num_exposed, 1:end);  % come back. Are these the right shapes for B?
            B2 = obj.B(num_exposed+1:end, 1:end);

            % Follow DSF derivations

            sI_A4inv = DSF.sI_MINV(A4);
            W = A1 + (A2 * sI_A4inv * A3);
            V = (A2 * sI_A4inv * B2) + B1;

            D = diag(diag(W));
            sI_Dinv = DSF.sI_MINV(D);

            Q = sI_Dinv * (W-D);
            P = sI_Dinv * V;
        end

        function H = vulnerability_matrix(~, Q)
            % Compute the vulnerability of the system. 
            % This ought to be only computed once (use the 'abstract'
            % method to update any initial vulnerability matrix).
            % Parameters: 
            %   Q : This is the Q matrix from DSF

            I = DSF.identity_like(Q);
            H = inv(I - Q);
        end

        function [vulnerability, index, V] = eval_vulnerability(~, H)
            % Compute the maximum entry of the vulnerability matrix H under
            % the H-infinity norm.
            % Parameters:
            %   H : vulnerability matrix

            [n, ~] = size(H);
            vulnerability = 0;
            V = zeros(n);
            index = [1, 1];
            for i = 1:n
                for j = 1:n
                    [num, den] = numden(H(i,j));  % num/den of tf entry
                    % coeffs(s^3 + 3s^2 + 10) -> [10, 0, 3, 1]
                    num_coeffs = coeffs(num);
                    den_coeffs = coeffs(den);
                    % convert coeffs to matlab array and reverse order
                    tf_ij = tf(flip(double(num_coeffs)), flip(double(den_coeffs)));
                    V_ij = hinfnorm(tf_ij);  % entry wise inf norm
                    V(i, j) = V_ij;
                    % update the max
                    if V_ij > vulnerability
                        vulnerability = V_ij;
                        index = [i, j];
                    end
                end
            end
        end

        function H_new = abstract(~, H, num_exposed, Q, invert_hidden_size)
            % Update the vulnerability matrix
            % Parameters:
            %   H : current vulnerability matrix
            %   num_exposed : How many states will be exposed after update
            %   Q (optional) : Q from DSF
            %   invert_hidden_size (optional) : Alternative to computing
            %                      H1^-1. 1 == True.

            % Partition matrices

            H1 = H(1:num_exposed, 1:num_exposed);
            H2 = H(1:num_exposed, num_exposed+1:end);
            H3 = H(num_exposed+1:end, 1:num_exposed);
            H4 = H(num_exposed+1:end, num_exposed+1:end);

            if invert_hidden_size == 1
                Q1 = Q(1:num_exposed, 1:num_exposed);
                Q2 = Q(1:num_exposed, num_exposed+1:end);
                Q3 = Q(num_exposed+1:end, 1:num_exposed);
                Q4 = Q(num_exposed+1:end, num_exposed+1:end);

                inv_diag = diag(diag(eye(num_exposed) - Q1 - Q2 * inv(DSF.identity_like(Q4) - Q4)*Q3));
                H_new = H1 * inv_diag;
            else
                H_new = H1 * diag(diag(inv(H1)));
            end
        end

        function G = convertDSFtoTF(~, Q, P)
            % Take a DSF and find the transfer function of the system
            % Parameters:
            %   Q, P : (Q,P) from DSF.

            I_Qinv = inv(DSF.identity_like(Q) - Q);
            G = I_Qinv * P;
        end
    end
end


