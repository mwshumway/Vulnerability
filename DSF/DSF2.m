classdef DSF2
    %DSF2 Summary of this class goes here
    %   Detailed explanation goes here

    properties
        A
        Q
        H
        V
        vulnerability
    end

    methods (Static)
        function result = build(Q, H, V, vulnerability)
            %build 
            result = DSF2([1]);
            result.Q = Q;
            result.H = H;
            result.V = V;
            result.vulnerability = vulnerability;
        end
    end

    methods
        function obj = DSF2(A)
            %DSF2 Construct an instance of this class
            [n, ~] = size(A);
            diag_A = diag(diag(A));
            obj.A = A;
            
            syms s;
            sI_minus_diag_A = s*eye(n) - diag_A;

            obj.Q = inv(sI_minus_diag_A) * (A - diag_A);
            obj.H = inv(s*eye(n) - A) * sI_minus_diag_A;

            V = zeros(n);
            for i = 1:n
                for j = 1:n
                    [num, den] = numden(obj.H(i,j));  % num/den of tf entry
                    % coeffs(s^3 + 3s^2 + 10) -> [10, 0, 3, 1]
                    num_coeffs = coeffs(num);
                    den_coeffs = coeffs(den);
                    % convert coeffs to matlab array and reverse order
                    tf_ij = tf(flip(double(num_coeffs)), flip(double(den_coeffs)));
                    V_ij = hinfnorm(tf_ij);  % entry wise inf norm
                    V(i, j) = V_ij;
                end
            end
            obj.V = V;
            obj.vulnerability = max(V);

        end

        function res = immerse(obj, Y_bit_set)
            if Y_bit_set == 0
                res = DSF2.build([], [], [], 0);
                return;
            end
            Y_bit_set = dec2bin(Y_bit_set); Y_bit_set = fliplr(Y_bit_set); 
            Y_bit_set = arrayfun(@(x) str2double(x), Y_bit_set);

            Y_indices = find(Y_bit_set);  % Find indices where Y_bit_set is non-zero (true)
            
            % Check if only one index is found
            if length(Y_indices) == 1
                res = DSF2.build([0], [1], [1], 1);
                return;
            end
            
            % Create Z_indices, assuming self.V is already defined and has a shape or size property
            Z_indices = setdiff(1:size(obj.V, 1), Y_indices);

            Y_ident = zeros(length(Y_indices), size(obj.V, 1));

            for i = 1: length(Y_indices)
                Y_ident(i, Y_indices(i)) = 1;
            end

            Z_ident = zeros(length(Z_indices), size(obj.V, 1));
            for i = 1: length(Z_indices)
                Z_ident(i, Z_indices(i)) = 1;
            end
            
            Q1 = Y_ident * obj.Q * Y_ident.';
            Q2 = Y_ident * obj.Q * Z_ident.';
            Q3 = Z_ident * obj.Q * Y_ident.';
            Q4 = Z_ident * obj.Q * Z_ident.';
        
            H1 = Y_ident * obj.H * Y_ident.';
            H2 = Y_ident * obj.H * Z_ident.';
            H3 = Z_ident * obj.H * Y_ident.';
            H4 = Z_ident * obj.H * Z_ident.';

            new_Q = Q1 + Q2 * inv(eye(size(Q4,1)) - Q4) * Q3;
            new_H = (H1 * diag(diag(eye(size(new_Q, 1)) - new_Q)));
            diag_new_Q = diag(diag(new_Q));
            new_Q = inv(eye(size(diag_new_Q, 1)) - diag_new_Q) * (new_Q - diag_new_Q);
            n2 = size(new_H, 1);
            new_V = zeros(n2);
            for i = 1:n2
                for j = 1:n2
                    [num, den] = numden(new_H(i,j));  % num/den of tf entry
                    % coeffs(s^3 + 3s^2 + 10) -> [10, 0, 3, 1]
                    num_coeffs = coeffs(num);
                    den_coeffs = coeffs(den);
                    % convert coeffs to matlab array and reverse order
                    tf_ij = tf(flip(double(num_coeffs)), flip(double(den_coeffs)));
                    V_ij = hinfnorm(tf_ij);  % entry wise inf norm
                    new_V(i, j) = V_ij;
                end
            end
            new_vulnerability = max(new_V, [], "all");

            res = DSF2.build(new_Q, new_H, new_V, new_vulnerability);
        end
    end
end