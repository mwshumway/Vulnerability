function [policy, idx_n] = Optimal_Policy(A, B)
%OPTIMAL_POLICY given a system (A, B), determine which nodes are optimal to
%remove at each abstraction
% NOTE - Currently only implemented to compute the first step of
% abstracting 1 state from n -> n-1.
    
    [n, ~] = size(A);
    % First, get it working for the first step (n -> n-1)
    dsf = DSF(A, B);
    [Q, ~] = dsf.dsf(n);
    H = dsf.vulnerability_matrix(Q);
    [v_n, idx_n, V_n] = dsf.eval_vulnerability(H);  % vulnerability with no abstraction

    vulnerabilities = [];

    for i = 1: n
        % to 'remove' the node, we will column and row swap the ith and
        % last row/col, and then call our abstraction code
        % Row/col swaps
        A_i = A;
        A_i([i, end], :) = A_i([end, i], :);
        A_i(:, [i, end]) = A_i(:, [end, i]);
        % Compute vulnerabilities
        dsf = DSF(A_i, B);
        [Q, ~] = dsf.dsf(n);
        H = dsf.vulnerability_matrix(Q);
        H_i = dsf.abstract(H, n-1, 0, 0);
        [v_i, idx_i, V_i] = dsf.eval_vulnerability(H_i);
        vulnerabilities = [vulnerabilities; v_i];
    end

    [~, policy] = min(vulnerabilities);
end